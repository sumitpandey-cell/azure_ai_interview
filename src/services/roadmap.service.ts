import { GoogleGenerativeAI } from '@google/generative-ai';
import { supabase } from '@/integrations/supabase/client';
import { analyticsService } from './analytics.service';

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.NEXT_PUBLIC_GEMINI_API_KEY || '');

export interface PaymentEligibility {
    requiresPayment: boolean;
    roadmapCount: number;
    amount: number;
    currency: string;
}

class RoadmapService {
    /**
     * Check if user needs to pay for roadmap generation
     */
    async checkPaymentEligibility(userId: string, supabaseClient?: any): Promise<PaymentEligibility> {
        try {
            const client = supabaseClient || supabase;
            // Count total roadmaps generated by user
            const { count } = await client
                .from('learning_roadmaps')
                .select('*', { count: 'exact', head: true })
                .eq('user_id', userId);

            const roadmapCount = count || 0;

            return {
                requiresPayment: roadmapCount >= 1,
                roadmapCount,
                amount: roadmapCount >= 1 ? 99 : 0,
                currency: 'INR',
            };
        } catch (error) {
            console.error('Error checking payment eligibility:', error);
            return {
                requiresPayment: false,
                roadmapCount: 0,
                amount: 0,
                currency: 'INR',
            };
        }
    }

    /**
     * Generate personalized roadmap for user
     * @param paymentId - Optional payment ID for paid roadmaps
     * @param force - Whether to force generation even if an active one exists
     * @param supabaseClient - Optional Supabase client (for server-side calls)
     */
    async generateRoadmap(userId: string, paymentId?: string, supabaseClient?: any, force: boolean = false) {
        const client = supabaseClient || supabase;
        let placeholderId: string | null = null;

        try {
            // 1. Check for existing active roadmap (skip if forcing)
            if (!force) {
                const existing = await this.getActiveRoadmap(userId, client);
                if (existing) {
                    if (existing.roadmap_data?.status === 'generating') {
                        // Check if it's stuck (e.g., more than 5 minutes old)
                        const createdAt = new Date(existing.created_at).getTime();
                        const now = new Date().getTime();
                        if (now - createdAt < 5 * 60 * 1000) {
                            return existing; // Still generating
                        } else {
                            // Stuck, deactivate it
                            await client
                                .from('learning_roadmaps')
                                .update({ is_active: false })
                                .eq('id', existing.id);
                        }
                    } else if (!this.isExpired(existing)) {
                        return existing;
                    }
                }
            }

            // 2. Check payment eligibility
            const eligibility = await this.checkPaymentEligibility(userId, client);

            // 3. If payment required but not provided, throw error
            if (eligibility.requiresPayment && !paymentId) {
                throw new Error('Payment required for additional roadmap');
            }

            // 4. Fetch user's interview history
            const history = await analyticsService.getUserInterviewHistory(userId, client);

            // 5. Check eligibility (minimum 3 completed interviews)
            if (history.completed.length < 3) {
                throw new Error('Minimum 3 completed interviews required');
            }

            // 11. Deactivate any existing active roadmaps before starting
            await client
                .from('learning_roadmaps')
                .update({ is_active: false })
                .eq('user_id', userId)
                .eq('is_active', true);

            // 11b. Insert placeholder record to track status
            const { data: placeholder, error: insertError } = await client
                .from('learning_roadmaps')
                .insert({
                    user_id: userId,
                    overall_level: 'Beginner', // temporary
                    roadmap_data: { status: 'generating' },
                    version: 1,
                    is_paid: !(!eligibility.requiresPayment),
                    payment_amount: !eligibility.requiresPayment ? 0 : 99,
                    payment_id: paymentId || null,
                    payment_status: !eligibility.requiresPayment ? 'free' : 'pending',
                    generated_at: new Date().toISOString(),
                    expires_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),
                    is_active: true,
                })
                .select()
                .single();

            if (insertError) throw insertError;
            placeholderId = placeholder.id;

            // 6. Build AI prompt
            const prompt = this.buildAnalysisPrompt(history);

            // 7. Call Gemini AI with retry logic
            let roadmapData;
            try {
                const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
                const result = await model.generateContent(prompt);
                const responseText = result.response.text();

                // Clean potential markdown formatting
                const jsonText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                roadmapData = JSON.parse(jsonText);
            } catch (aiError) {
                console.error('Gemini AI error:', aiError);
                // Retry once with same model
                const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' });
                const result = await model.generateContent(prompt);
                const responseText = result.response.text();
                const jsonText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                roadmapData = JSON.parse(jsonText);
            }

            // 8. Validate roadmap structure
            if (!roadmapData.phases || roadmapData.phases.length < 2) {
                throw new Error('Invalid roadmap structure from AI');
            }

            // 9. Determine overall level
            const overallLevel = this.calculateOverallLevel(history);

            // 10. Determine payment status
            const isFree = !eligibility.requiresPayment;
            const paymentStatus = isFree ? 'free' : 'completed';
            const paymentAmount = isFree ? 0 : 99;

            // 12. Update placeholder with real data
            const { data, error: updateError } = await client
                .from('learning_roadmaps')
                .update({
                    overall_level: overallLevel,
                    roadmap_data: roadmapData,
                    payment_status: paymentStatus,
                    generated_at: new Date().toISOString(),
                })
                .eq('id', placeholderId)
                .eq('user_id', userId)
                .select()
                .single();

            if (updateError) throw updateError;
            return data;
        } catch (error: any) {
            console.error('Error generating roadmap:', error);
            // Cleanup placeholder if it exists and failed (only if it was an AI/Update error)
            if (placeholderId && error.code !== '42501') {
                try {
                    await client
                        .from('learning_roadmaps')
                        .delete()
                        .eq('id', placeholderId)
                        .eq('user_id', userId);
                } catch (cleanupErr) {
                    console.error('Failed to cleanup placeholder:', cleanupErr);
                }
            }
            throw error;
        }
    }

    /**
     * Build comprehensive prompt for Gemini AI
     */
    private buildAnalysisPrompt(history: any): string {
        return `You are an expert career coach and technical interview mentor. Analyze the following interview history and create a personalized learning roadmap.

## Interview History Data:
${JSON.stringify(history, null, 2)}

## Your Task:
Generate a comprehensive, actionable learning roadmap in JSON format with the following structure:

{
  "analysis": {
    "total_interviews": <number>,
    "average_score": <number>,
    "completion_rate": <percentage>,
    "strengths": [<list of 3-5 key strengths>],
    "weaknesses": [<list of 3-5 areas needing improvement>],
    "trend": "improving" | "stable" | "declining"
  },
  "improvement_areas": [
    {
      "skill": "<skill name>",
      "current_level": <1-10>,
      "target_level": <1-10>,
      "priority": "High" | "Medium" | "Low",
      "estimated_time_weeks": <number>
    }
  ],
  "phases": [
    {
      "phase_number": 1,
      "title": "<phase title>",
      "description": "<what to focus on>",
      "duration_weeks": <number>,
      "goals": [
        {
          "id": "<unique-id>",
          "description": "<specific goal>",
          "success_criteria": "<how to measure success>"
        }
      ],
      "recommended_interviews": [
        {
          "template_id": "backend-intermediate",
          "template_title": "<title>",
          "difficulty": "Beginner" | "Intermediate" | "Advanced",
          "frequency": "<e.g., 2x per week>",
          "focus_areas": [<specific skills to practice>]
        }
      ],
      "learning_resources": [
        {
          "type": "article" | "video" | "practice",
          "title": "<resource title>",
          "description": "<brief description>",
          "url": "<optional URL>",
          "estimated_time_minutes": <number>
        }
      ]
    }
  ],
  "milestones": [
    {
      "id": "<unique-id>",
      "title": "<milestone title>",
      "description": "<what this achieves>",
      "target_score": <score to achieve>,
      "phase_number": <which phase>,
      "estimated_date": "<YYYY-MM-DD>"
    }
  ]
}

## Guidelines:
1. Create 3-4 phases spanning 8-12 weeks total
2. Be specific and actionable with goals
3. Consider the user's current skill level and progression trend
4. Include both technical and soft skills (communication, problem-solving)
5. Suggest realistic practice frequency (2-3x per week is ideal)
6. Provide diverse learning resources (articles, videos, practice problems)
7. Set achievable milestones with specific target scores
8. Estimated dates should be from today forward

Return ONLY valid JSON, no markdown formatting, no code blocks, just the raw JSON object.`;
    }

    /**
     * Get active roadmap for user
     */
    async getActiveRoadmap(userId: string, supabaseClient?: any) {
        try {
            const client = supabaseClient || supabase;
            const { data, error } = await client
                .from('learning_roadmaps')
                .select('*')
                .eq('user_id', userId)
                .eq('is_active', true)
                .order('created_at', { ascending: false })
                .limit(1)
                .maybeSingle();

            if (error) {
                console.error('Error fetching active roadmap:', error);
                return null;
            }

            if (data && this.isExpired(data)) {
                // If the most recent active roadmap is expired, deactivate it
                await client
                    .from('learning_roadmaps')
                    .update({ is_active: false })
                    .eq('id', data.id);
                return null;
            }

            // Check if stuck in generating state
            if (data && data.roadmap_data?.status === 'generating') {
                const createdAt = new Date(data.created_at).getTime();
                const now = new Date().getTime();
                if (now - createdAt > 10 * 60 * 1000) { // 10 minutes timeout
                    await client
                        .from('learning_roadmaps')
                        .update({ is_active: false })
                        .eq('id', data.id);
                    return null;
                }
            }

            return data;
        } catch (error) {
            console.error('Roadmap service getActiveRoadmap error:', error);
            return null;
        }
    }

    /**
     * Refresh roadmap (deactivate old, generate new)
     */
    async refreshRoadmap(userId: string, paymentId?: string, supabaseClient?: any) {
        return this.generateRoadmap(userId, paymentId, supabaseClient, true);
    }

    /**
     * Track progress on roadmap item
     */
    async trackProgress(
        userId: string,
        roadmapId: string,
        itemType: string,
        itemId: string,
        phaseNumber?: number,
        notes?: string,
        supabaseClient?: any
    ) {
        try {
            const client = supabaseClient || supabase;

            // Check if already completed
            const { data: existing } = await client
                .from('roadmap_progress')
                .select('id')
                .eq('user_id', userId)
                .eq('roadmap_id', roadmapId)
                .eq('milestone_id', itemId)
                .single();

            if (existing) {
                // Already completed, return existing
                return existing;
            }

            // Insert new progress
            const { data, error } = await client
                .from('roadmap_progress')
                .insert({
                    roadmap_id: roadmapId,
                    user_id: userId,
                    item_type: itemType,
                    milestone_id: itemId,
                    phase_number: phaseNumber,
                    notes,
                })
                .select()
                .single();

            if (error) throw error;
            return data;
        } catch (error) {
            console.error('Error tracking progress:', error);
            throw error;
        }
    }

    /**
     * Get user's progress on current roadmap
     */
    async getProgress(userId: string, roadmapId: string, supabaseClient?: any) {
        try {
            const client = supabaseClient || supabase;
            const { data } = await client
                .from('roadmap_progress')
                .select('*')
                .eq('user_id', userId)
                .eq('roadmap_id', roadmapId)
                .order('completed_at', { ascending: false });

            return data || [];
        } catch (error) {
            console.error('Error fetching progress:', error);
            return [];
        }
    }

    /**
     * Calculate overall skill level based on interview history
     */
    private calculateOverallLevel(history: any): 'Beginner' | 'Intermediate' | 'Advanced' {
        const avgScore = history.stats?.average_score || 0;

        if (avgScore < 50) return 'Beginner';
        if (avgScore < 75) return 'Intermediate';
        return 'Advanced';
    }

    /**
     * Check if roadmap is expired
     */
    private isExpired(roadmap: any): boolean {
        return new Date(roadmap.expires_at) < new Date();
    }
}

export const roadmapService = new RoadmapService();
